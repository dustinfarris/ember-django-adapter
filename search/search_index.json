{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ember Django Adapter Documentation Ember Django Adapter (EDA) enables users to build applications using Django REST Framework and Ember.js. The two packages work with REST APIs, but differ on certain JSON formatting and semantics. Fortunately, Ember Data (the library powering Ember.js models) provides an opportunity to write custom adapters to bridge these differences. EDA is one such adapter specifically designed to work with Django REST Framework. Requirements To build a project using Ember Django Adapter, you will need to be using: Django REST Framework >= 3.0 Ember Data >= 1.13.7 note: Ember Data 1.13.x requires ember 1.12.1 and later Ember CLI >= 0.2.7 Quickstart In your Ember CLI project, install Ember Django Adapter from the command line: ember install ember-django-adapter See configuring for more information on customizing the adapter.","title":"Introduction"},{"location":"#ember-django-adapter-documentation","text":"Ember Django Adapter (EDA) enables users to build applications using Django REST Framework and Ember.js. The two packages work with REST APIs, but differ on certain JSON formatting and semantics. Fortunately, Ember Data (the library powering Ember.js models) provides an opportunity to write custom adapters to bridge these differences. EDA is one such adapter specifically designed to work with Django REST Framework.","title":"Ember Django Adapter Documentation"},{"location":"#requirements","text":"To build a project using Ember Django Adapter, you will need to be using: Django REST Framework >= 3.0 Ember Data >= 1.13.7 note: Ember Data 1.13.x requires ember 1.12.1 and later Ember CLI >= 0.2.7","title":"Requirements"},{"location":"#quickstart","text":"In your Ember CLI project, install Ember Django Adapter from the command line: ember install ember-django-adapter See configuring for more information on customizing the adapter.","title":"Quickstart"},{"location":"changelog/","text":"ember-django-adapter Changelog 2.1.1 Internal #225 : Update error class imports (@gojefferson) #220 : Update adapter errors imports & make ember-data a peer dependency (@gojefferson) 2.1.0 Enhancements #215 : Support ember-data 3.0 (@benmurden, @OleRoel) Internal #217 : Upgrade to CircleCI 2.0 (@benmurden) Docs #209 : Update coalesce-find-requests code sample (@arnebit) 2.0.0 Enhancements #207 : Update ember and ember-data to 2.17. Fix deprecations. #172 : clean Ember.merge deprecation and fix jshintrc Internal #186 : Update ember-sinon to the latest version #180 : Update ember-resolver to the latest version #174 : Update ember-cli-jshint to the latest version #167 : Update dependencies to enable Greenkeeper Docs #175 : Update pagination.md 1.1.3 [INTERNAL] Upgrade ember-cli to 1.13.15 ( #157 ) [ENHANCEMENT] Allow addon to be used in a another addon ( #164 ) [BUGFIX] Map payload strings to arrays ( #165 ) 1.1.2 [ENHANCMENT] Register addon with Ember libraries ( #142 ) [BUGFIX] Do not check for count attribute in paginated response ( #143 ) [DOCS] Note to disable pagination for coalesced records ( #145 ) 1.1.1 [BUGFIX] Support nested errors returned by DRF ( #141 ) [BUGFIX] Do not require page query param on pagination previous link ( #140 ) [INTERNAL] Upgrade ember and ember-cli to latest ( #138 ) 1.1.0 [ENHANCEMENT] Extend DS.RESTSerializer ( #133 ) 1.0.0 [BREAKING ENHANCEMENT] Update to new Ember Data 1.13 serializer API ( #114 ) [ENHANCEMENT] Support ember-data 1.13 series ( #108 ) [ENHANCEMENT] Support HyperlinkedRelatedFields ( #95 ) [ENHANCEMENT] Support object-level errors ( #123 ) [ENHANCEMENT] Support query parameter in buildURL ( #124 ) [BUGFIX] Remove coalesceFindRequests warning ( #106 ) [INTERNAL] Updated ember-cli version to latest (1.13.1) ( #112 ) [INTERNAL] Test for setting an explicit id on createRecord ( #117 ) [INTERNAL] Acceptance test for embedded records ( #119 ) [INTERNAL] Test for embedded belongsTo create with id ( #120 ) [DOCS] Using ember-cli-pagination with the adapter ( #101 ) 0.5.6 [INTERNAL] Updated ember-cli version to latest (0.2.7) ( #99 ) [INTERNAL] Updated ember-cli version to latest (0.2.6) ( #97 ) [ENHANCEMENT] Support ember-data 1.0.0-beta.18 ( #96 ) [INTERNAL] Add tests for relationships support ( #94 ) [INTERNAL] Updated ember-cli version to latest (0.2.5) ( #91 ) 0.5.5 [INTERNAL] Updated ember-cli version to latest (0.2.4) ( #89 ) [BUGFIX] All find queries are now handled properly ( #88 ) 0.5.4 [INTERNAL] Updated ember-cli version to latest (0.2.3) ( #81 ) [ENHANCEMENT] Modified signatures of methods in serializer and adapter to comply with changes introduced in ember-data v1.0.0-beta.15 and in v1.0.0-beta.16 (snapshots instead of records) ( #74 ) ( #77 ) ( #84 ) [INTERNAL] Use ember-try to enable a test matrix ( #85 ) 0.5.3 [BREAKING ENHANCEMENT] Remove trailing slashes environment config ( #67 ) [DOCS] Add Google Analytics to documentation site ( #69 ) [ENHANCEMENT] Support added for coalesceFindRequests ( #68 ) [INTERNAL] Revised goals for the adapter ( #70 ) 0.5.2 [BUGFIX] Return jqXHR for non-400 errors ( #62 ) [BREAKING BUGFIX] Set default host to localhost:8000 ( #64 ) [DOCS] Update installation instructions ( #65 ) 0.5.1 [ENHANCEMENT] Add support for pagination metadata ( #45 ) [ENHANCEMENT] Add documentation for contributing ( #49 ) [ENHANCEMENT] Add blueprints and support for embedded records ( #51 ) [ENHANCEMENT] Add option to remove trailing slashes ( #50 ) [ENHANCEMENT] Test coverage for all supported versions of ember-data ( #56 ) 0.5.0 [BREAKING REFACTOR] Rewrite toranb/ember-data-django-rest-adapter as an ember-cli addon","title":"Changelog"},{"location":"changelog/#ember-django-adapter-changelog","text":"","title":"ember-django-adapter Changelog"},{"location":"changelog/#211","text":"","title":"2.1.1"},{"location":"changelog/#internal","text":"#225 : Update error class imports (@gojefferson) #220 : Update adapter errors imports & make ember-data a peer dependency (@gojefferson)","title":"Internal"},{"location":"changelog/#210","text":"","title":"2.1.0"},{"location":"changelog/#enhancements","text":"#215 : Support ember-data 3.0 (@benmurden, @OleRoel)","title":"Enhancements"},{"location":"changelog/#internal_1","text":"#217 : Upgrade to CircleCI 2.0 (@benmurden)","title":"Internal"},{"location":"changelog/#docs","text":"#209 : Update coalesce-find-requests code sample (@arnebit)","title":"Docs"},{"location":"changelog/#200","text":"","title":"2.0.0"},{"location":"changelog/#enhancements_1","text":"#207 : Update ember and ember-data to 2.17. Fix deprecations. #172 : clean Ember.merge deprecation and fix jshintrc","title":"Enhancements"},{"location":"changelog/#internal_2","text":"#186 : Update ember-sinon to the latest version #180 : Update ember-resolver to the latest version #174 : Update ember-cli-jshint to the latest version #167 : Update dependencies to enable Greenkeeper","title":"Internal"},{"location":"changelog/#docs_1","text":"#175 : Update pagination.md","title":"Docs"},{"location":"changelog/#113","text":"[INTERNAL] Upgrade ember-cli to 1.13.15 ( #157 ) [ENHANCEMENT] Allow addon to be used in a another addon ( #164 ) [BUGFIX] Map payload strings to arrays ( #165 )","title":"1.1.3"},{"location":"changelog/#112","text":"[ENHANCMENT] Register addon with Ember libraries ( #142 ) [BUGFIX] Do not check for count attribute in paginated response ( #143 ) [DOCS] Note to disable pagination for coalesced records ( #145 )","title":"1.1.2"},{"location":"changelog/#111","text":"[BUGFIX] Support nested errors returned by DRF ( #141 ) [BUGFIX] Do not require page query param on pagination previous link ( #140 ) [INTERNAL] Upgrade ember and ember-cli to latest ( #138 )","title":"1.1.1"},{"location":"changelog/#110","text":"[ENHANCEMENT] Extend DS.RESTSerializer ( #133 )","title":"1.1.0"},{"location":"changelog/#100","text":"[BREAKING ENHANCEMENT] Update to new Ember Data 1.13 serializer API ( #114 ) [ENHANCEMENT] Support ember-data 1.13 series ( #108 ) [ENHANCEMENT] Support HyperlinkedRelatedFields ( #95 ) [ENHANCEMENT] Support object-level errors ( #123 ) [ENHANCEMENT] Support query parameter in buildURL ( #124 ) [BUGFIX] Remove coalesceFindRequests warning ( #106 ) [INTERNAL] Updated ember-cli version to latest (1.13.1) ( #112 ) [INTERNAL] Test for setting an explicit id on createRecord ( #117 ) [INTERNAL] Acceptance test for embedded records ( #119 ) [INTERNAL] Test for embedded belongsTo create with id ( #120 ) [DOCS] Using ember-cli-pagination with the adapter ( #101 )","title":"1.0.0"},{"location":"changelog/#056","text":"[INTERNAL] Updated ember-cli version to latest (0.2.7) ( #99 ) [INTERNAL] Updated ember-cli version to latest (0.2.6) ( #97 ) [ENHANCEMENT] Support ember-data 1.0.0-beta.18 ( #96 ) [INTERNAL] Add tests for relationships support ( #94 ) [INTERNAL] Updated ember-cli version to latest (0.2.5) ( #91 )","title":"0.5.6"},{"location":"changelog/#055","text":"[INTERNAL] Updated ember-cli version to latest (0.2.4) ( #89 ) [BUGFIX] All find queries are now handled properly ( #88 )","title":"0.5.5"},{"location":"changelog/#054","text":"[INTERNAL] Updated ember-cli version to latest (0.2.3) ( #81 ) [ENHANCEMENT] Modified signatures of methods in serializer and adapter to comply with changes introduced in ember-data v1.0.0-beta.15 and in v1.0.0-beta.16 (snapshots instead of records) ( #74 ) ( #77 ) ( #84 ) [INTERNAL] Use ember-try to enable a test matrix ( #85 )","title":"0.5.4"},{"location":"changelog/#053","text":"[BREAKING ENHANCEMENT] Remove trailing slashes environment config ( #67 ) [DOCS] Add Google Analytics to documentation site ( #69 ) [ENHANCEMENT] Support added for coalesceFindRequests ( #68 ) [INTERNAL] Revised goals for the adapter ( #70 )","title":"0.5.3"},{"location":"changelog/#052","text":"[BUGFIX] Return jqXHR for non-400 errors ( #62 ) [BREAKING BUGFIX] Set default host to localhost:8000 ( #64 ) [DOCS] Update installation instructions ( #65 )","title":"0.5.2"},{"location":"changelog/#051","text":"[ENHANCEMENT] Add support for pagination metadata ( #45 ) [ENHANCEMENT] Add documentation for contributing ( #49 ) [ENHANCEMENT] Add blueprints and support for embedded records ( #51 ) [ENHANCEMENT] Add option to remove trailing slashes ( #50 ) [ENHANCEMENT] Test coverage for all supported versions of ember-data ( #56 )","title":"0.5.1"},{"location":"changelog/#050","text":"[BREAKING REFACTOR] Rewrite toranb/ember-data-django-rest-adapter as an ember-cli addon","title":"0.5.0"},{"location":"coalesce-find-requests/","text":"Coalescing Find Requests When a record returns the IDs of records in a hasMany relationship, Ember Data allows us to opt-in to combine these requests into a single request. Note: Using hyperlinked related fields to retrieve related records in a single request is preferred over using coalesceFindRequests since there is a limit on the number of records per request on read-only fields due to URL length restrictions. Suppose you have Ember models: // app/models/person.js import DS from 'ember-data'; export default DS.Model.extend({ name: DS.attr('string'), pets: DS.hasMany('pet', { async: True }) }); // app/models/pet.js import DS from 'ember-data'; export default DS.Model.extend({ age: DS.attr('number') }); An out-of-the-box DRF model serializer for Person would return something like this: GET /api/people/1/ { \"id\": 1, \"name\": \"Fred\", \"pets\": [1, 2, 3] } When Ember Data decides to resolve the pets, by default it would fire 3 separate requests. In this case: GET /api/pets/1/ { \"id\": 1, \"age\": 5 } GET /api/pets/2/ { \"id\": 2, \"age\": 5 } GET /api/pets/3/ { \"id\": 3, \"age\": 6 } However, if we opt-in to coalesceFindRequests, we can consolidate this into 1 call. Enable coalesceFindRequests Extend the adapter, and enable coalesceFindRequests: // app/adapters/application.js import DRFAdapter from './drf'; export default DRFAdapter.extend({ coalesceFindRequests: true }); Now, when Ember Data resolves the pets, it will fire a request that looks like this: GET /api/pets/?ids[]=1&ids[]=2&ids[]=3 CoalesceFilterBackend All this is great, except Django REST Framework is not quite able to handle such a request out of the box. Thankfully, DRF allows you to plug in custom filters , and writing a filter for this kind of request is super simple. In your project somewhere, write the following filter: # myapp/filters.py from rest_framework import filters class CoalesceFilterBackend(filters.BaseFilterBackend): \"\"\" Support Ember Data coalesceFindRequests. \"\"\" def filter_queryset(self, request, queryset, view): id_list = request.query_params.getlist('ids[]') if id_list: # Disable pagination, so all records can load. view.pagination_class = None queryset = queryset.filter(id__in=id_list) return queryset Now you just need to add this filter to filter_backends in your views, e.g.: from myapp.filters import CoalesceFilterBackend class UserListView(generics.ListAPIView): queryset = User.objects.all() serializer = UserSerializer filter_backends = (CoalesceFilterBackend,) Or, configure it globally in your DRF settings: REST_FRAMEWORK = { 'DEFAULT_FILTER_BACKENDS': ('myapp.filters.CoalesceFilterBackend',) } Now, when Ember Data sends the coalesced request, DRF will return meaningful data: GET /api/pets/?ids[]=1&ids[]=2&ids[]=3 [ { \"id\": 1, \"age\": 5 }, { \"id\": 2, \"age\": 5 }, { \"id\": 3, \"age\": 6 } ]","title":"Coalesce Find Requests"},{"location":"coalesce-find-requests/#coalescing-find-requests","text":"When a record returns the IDs of records in a hasMany relationship, Ember Data allows us to opt-in to combine these requests into a single request. Note: Using hyperlinked related fields to retrieve related records in a single request is preferred over using coalesceFindRequests since there is a limit on the number of records per request on read-only fields due to URL length restrictions. Suppose you have Ember models: // app/models/person.js import DS from 'ember-data'; export default DS.Model.extend({ name: DS.attr('string'), pets: DS.hasMany('pet', { async: True }) }); // app/models/pet.js import DS from 'ember-data'; export default DS.Model.extend({ age: DS.attr('number') }); An out-of-the-box DRF model serializer for Person would return something like this: GET /api/people/1/ { \"id\": 1, \"name\": \"Fred\", \"pets\": [1, 2, 3] } When Ember Data decides to resolve the pets, by default it would fire 3 separate requests. In this case: GET /api/pets/1/ { \"id\": 1, \"age\": 5 } GET /api/pets/2/ { \"id\": 2, \"age\": 5 } GET /api/pets/3/ { \"id\": 3, \"age\": 6 } However, if we opt-in to coalesceFindRequests, we can consolidate this into 1 call.","title":"Coalescing Find Requests"},{"location":"coalesce-find-requests/#enable-coalescefindrequests","text":"Extend the adapter, and enable coalesceFindRequests: // app/adapters/application.js import DRFAdapter from './drf'; export default DRFAdapter.extend({ coalesceFindRequests: true }); Now, when Ember Data resolves the pets, it will fire a request that looks like this: GET /api/pets/?ids[]=1&ids[]=2&ids[]=3","title":"Enable coalesceFindRequests"},{"location":"coalesce-find-requests/#coalescefilterbackend","text":"All this is great, except Django REST Framework is not quite able to handle such a request out of the box. Thankfully, DRF allows you to plug in custom filters , and writing a filter for this kind of request is super simple. In your project somewhere, write the following filter: # myapp/filters.py from rest_framework import filters class CoalesceFilterBackend(filters.BaseFilterBackend): \"\"\" Support Ember Data coalesceFindRequests. \"\"\" def filter_queryset(self, request, queryset, view): id_list = request.query_params.getlist('ids[]') if id_list: # Disable pagination, so all records can load. view.pagination_class = None queryset = queryset.filter(id__in=id_list) return queryset Now you just need to add this filter to filter_backends in your views, e.g.: from myapp.filters import CoalesceFilterBackend class UserListView(generics.ListAPIView): queryset = User.objects.all() serializer = UserSerializer filter_backends = (CoalesceFilterBackend,) Or, configure it globally in your DRF settings: REST_FRAMEWORK = { 'DEFAULT_FILTER_BACKENDS': ('myapp.filters.CoalesceFilterBackend',) } Now, when Ember Data sends the coalesced request, DRF will return meaningful data: GET /api/pets/?ids[]=1&ids[]=2&ids[]=3 [ { \"id\": 1, \"age\": 5 }, { \"id\": 2, \"age\": 5 }, { \"id\": 3, \"age\": 6 } ]","title":"CoalesceFilterBackend"},{"location":"configuring/","text":"Configuring There are a number of configuration variables you can set in your environment.js file. API_HOST Default: 'http://localhost:8000' The fully-qualified host of your API server. API_NAMESPACE Default: 'api' The URL prefix (namespace) for your API. In other words, if you set this to my-api/v1, then all API requests will look like /my-api/v1/users/56/, or similar. Example // my-ember-cli-project/config/environment.js module.exports = function(environment) { var ENV = { APP: { } }; if (environment === 'development') { ENV.APP.API_HOST = 'http://localhost:8000'; } if (environment === 'production') { ENV.APP.API_HOST = 'https://api.myproject.com'; ENV.APP.API_NAMESPACE = 'v2'; } return ENV; };","title":"Configuring"},{"location":"configuring/#configuring","text":"There are a number of configuration variables you can set in your environment.js file.","title":"Configuring"},{"location":"configuring/#api_host","text":"Default: 'http://localhost:8000' The fully-qualified host of your API server.","title":"API_HOST"},{"location":"configuring/#api_namespace","text":"Default: 'api' The URL prefix (namespace) for your API. In other words, if you set this to my-api/v1, then all API requests will look like /my-api/v1/users/56/, or similar.","title":"API_NAMESPACE"},{"location":"configuring/#example","text":"// my-ember-cli-project/config/environment.js module.exports = function(environment) { var ENV = { APP: { } }; if (environment === 'development') { ENV.APP.API_HOST = 'http://localhost:8000'; } if (environment === 'production') { ENV.APP.API_HOST = 'https://api.myproject.com'; ENV.APP.API_NAMESPACE = 'v2'; } return ENV; };","title":"Example"},{"location":"contributing/","text":"Contributing to Ember Django Adapter We welcome all bug reports and pull requests. Issues: github.com/dustinfarris/ember-django-adapter/issues Local Development To run ember-django-adapter locally, you will have to use npm link . git clone git@github.com:dustinfarris/ember-django-adapter cd ember-django-adapter npm i && bower i npm link Then in a test ember-cli project, you will have to install a couple bower dependencies separately. These are not actually required in the test ember-cli project, but errors will be thrown if they are not present. cd test-ember-cli-project bower i pretender bower i http://sinonjs.org/releases/sinon-1.12.1.js npm link ember-django-adapter Now your test project is using a symlinked copy of your local ember-django-adapter, and any changes you make to the adapter will be reflected in your project in real-time. Running tests You can run tests with the latest supported Ember Data beta with: ember test You can also run tests against Ember Data canary with: ember try ember-data-canary","title":"Contributing"},{"location":"contributing/#contributing-to-ember-django-adapter","text":"We welcome all bug reports and pull requests. Issues: github.com/dustinfarris/ember-django-adapter/issues","title":"Contributing to Ember Django Adapter"},{"location":"contributing/#local-development","text":"To run ember-django-adapter locally, you will have to use npm link . git clone git@github.com:dustinfarris/ember-django-adapter cd ember-django-adapter npm i && bower i npm link Then in a test ember-cli project, you will have to install a couple bower dependencies separately. These are not actually required in the test ember-cli project, but errors will be thrown if they are not present. cd test-ember-cli-project bower i pretender bower i http://sinonjs.org/releases/sinon-1.12.1.js npm link ember-django-adapter Now your test project is using a symlinked copy of your local ember-django-adapter, and any changes you make to the adapter will be reflected in your project in real-time.","title":"Local Development"},{"location":"contributing/#running-tests","text":"You can run tests with the latest supported Ember Data beta with: ember test You can also run tests against Ember Data canary with: ember try ember-data-canary","title":"Running tests"},{"location":"embedded-records/","text":"Embedded Records Let's say you've set up a serializer in DRF that has embedded records. For example: class Person(models.Model): name = models.CharField(max_length=20) class Pet(models.Model): name = models.CharField(max_length=20) owner = models.ForeignKey(Person, related_name='pets') class PetSerializer(serializers.ModelSerializer): class Meta: model = Pet class PersonSerializer(serializers.ModelSerializer): pets = PetSerializer(many=True) class Meta: model = Person On the Ember side, your models would look like this: // app/models/pet.js import DS from 'ember-data'; export default DS.Model.extend({ person: DS.belongsTo('person'), name: DS.attr('string') }); // app/models/person.js import DS from 'ember-data'; export default DS.Model.extend({ name: DS.attr('string'), pets: DS.hasMany('pet') }); The API's JSON response from such a setup would look something like this: { \"id\": 2, \"name\": \"Frank\", \"pets\": [ { \"id\": 1, \"name\": \"Spot\" }, { \"id\": 2, \"name\": \"Fido\" } ] } Ember Data supports this sort of response (since 1.0.0-beta.10), but you will have to extend the serializer for this model to make Ember Data aware of it. In your Ember project, create a DRF serializer for your Person model. ember generate drf-serializer person This creates a skeleton serializer that extends the DRF serializer in app/serializers/person.js. Modify this file to support the embedded records: // app/serializers/person.js import DRFSerializer from './drf'; import DS from 'ember-data'; export default DRFSerializer.extend(DS.EmbeddedRecordsMixin, { attrs: { pets: { embedded: 'always' } } }); Writable nested records Writable nested records are not supported by the adapter at this time.","title":"Embedded Records"},{"location":"embedded-records/#embedded-records","text":"Let's say you've set up a serializer in DRF that has embedded records. For example: class Person(models.Model): name = models.CharField(max_length=20) class Pet(models.Model): name = models.CharField(max_length=20) owner = models.ForeignKey(Person, related_name='pets') class PetSerializer(serializers.ModelSerializer): class Meta: model = Pet class PersonSerializer(serializers.ModelSerializer): pets = PetSerializer(many=True) class Meta: model = Person On the Ember side, your models would look like this: // app/models/pet.js import DS from 'ember-data'; export default DS.Model.extend({ person: DS.belongsTo('person'), name: DS.attr('string') }); // app/models/person.js import DS from 'ember-data'; export default DS.Model.extend({ name: DS.attr('string'), pets: DS.hasMany('pet') }); The API's JSON response from such a setup would look something like this: { \"id\": 2, \"name\": \"Frank\", \"pets\": [ { \"id\": 1, \"name\": \"Spot\" }, { \"id\": 2, \"name\": \"Fido\" } ] } Ember Data supports this sort of response (since 1.0.0-beta.10), but you will have to extend the serializer for this model to make Ember Data aware of it. In your Ember project, create a DRF serializer for your Person model. ember generate drf-serializer person This creates a skeleton serializer that extends the DRF serializer in app/serializers/person.js. Modify this file to support the embedded records: // app/serializers/person.js import DRFSerializer from './drf'; import DS from 'ember-data'; export default DRFSerializer.extend(DS.EmbeddedRecordsMixin, { attrs: { pets: { embedded: 'always' } } });","title":"Embedded Records"},{"location":"embedded-records/#writable-nested-records","text":"Writable nested records are not supported by the adapter at this time.","title":"Writable nested records"},{"location":"extending/","text":"Extending the adapter/serializer More than likely, you will need to add you own tweaks to the adapter and (more often) the serializer. EDA provides blueprints to make this easy. For example, to make a customizable serializer for a User model: ember generate drf-serializer user This will create app/serializers/user.js for you to customize. Similarly, if you wanted to, for example, extend the adapter on the application level: ember generate drf-adapter application This will create app/adapters/application.js for you to customize.","title":"Extending"},{"location":"extending/#extending-the-adapterserializer","text":"More than likely, you will need to add you own tweaks to the adapter and (more often) the serializer. EDA provides blueprints to make this easy. For example, to make a customizable serializer for a User model: ember generate drf-serializer user This will create app/serializers/user.js for you to customize. Similarly, if you wanted to, for example, extend the adapter on the application level: ember generate drf-adapter application This will create app/adapters/application.js for you to customize.","title":"Extending the adapter/serializer"},{"location":"hyperlinked-related-fields/","text":"Hyperlinked Related Fields Ember Django Adapter has support for Django REST Framework's HyperlinkedRelatedField . URLs in a json hash for hasMany and belongsTo relationship fields will automatically be retrieved and added to the store. This feature has limited use without some configuration because related records are returned as multiple URLs which produces multiple requests. Sending multiple requests becomes a performance bottleneck when there are more than a few related URLs in the json hash. For example, this blog post json hash shows how a hasMany relationship is serialized by the default configuration of HyperlinkedRelatedField(many=True) : { \"id\": 11, \"title\": \"title 11\", \"body\": \"post 11\", \"comments\": [ \"http://example.com/api/comments/9/\", \"http://example.com/api/comments/10/\", \"http://example.com/api/comments/11/\" ] } As alluded to previously, related records can be retrieved in a single request by creating a custom ViewSet that allows the related records to be retrieved from a nested URL. For example, the blog post json hash would now have a single URL for the related comments instead of one URL per related record: { \"id\": 11, \"title\": \"title 11\", \"body\": \"post 11\", \"comments\": \"http://example.com/api/posts/11/comments/\" } Note: It is also possible to use the Coalesce Find Requests feature to retrieve related records in a single request, however, this is the preferred solution. Models, Serializers and Router We can create a blog post hash with the related comments URL by using the following models, serializers and router: # models.py class Post(models.Model): title = models.CharField(max_length=100) body = models.TextField() class Comment(models.Model): body = models.TextField() post = models.ForeignKey('Post', related_name='comments') # serializers.py class PostSerializer(serializers.HyperlinkedModelSerializer): comments = serializers.HyperlinkedIdentityField(view_name='post-comments') class Meta: model = Post fields = ('id', 'title', 'body', 'comments') class CommentSerializer(serializers.HyperlinkedModelSerializer): class Meta: model = Comment fields = ('id', 'body', 'post') # urls.py router = DefaultRouter() router.register(r'posts', PostViewSet) urlpatterns = router.urls ViewSet The nested comments URL is achieved by adding a @detail_route decorator on the comments method of the PostViewSet . The related comments are manually retrieved from the database and serialized. # views.py class PostViewSet(viewsets.ModelViewSet): serializer_class = PostSerializer queryset = Post.objects.all() @detail_route() def comments(self, request, pk=None): post = self.get_object() serializer = CommentSerializer(post.comments.all(), context={'request': request}, many=True) return Response(serializer.data) For example, retrieving the comments @detail_route using this nested URL http://example.com/api/posts/11/comments/ returns all of the related comments for post 11. [ { \"id\": 9, \"body\": \"comment 9\", \"post\": \"http://example.com/api/posts/11/\" }, { \"id\": 14, \"body\": \"comment 14\", \"post\": \"http://example.com/api/posts/11/\" } ] Write Operations In this example, the comments @detail_route is read-only. If you need to perform write operations on the specific related records (e.g. create, update or delete specific comments), you would need to add a top level API with the required operations for the related model (e.g. CommentViewSet on the /api/comments/ resource).","title":"Hyperlinked Related Fields"},{"location":"hyperlinked-related-fields/#hyperlinked-related-fields","text":"Ember Django Adapter has support for Django REST Framework's HyperlinkedRelatedField . URLs in a json hash for hasMany and belongsTo relationship fields will automatically be retrieved and added to the store. This feature has limited use without some configuration because related records are returned as multiple URLs which produces multiple requests. Sending multiple requests becomes a performance bottleneck when there are more than a few related URLs in the json hash. For example, this blog post json hash shows how a hasMany relationship is serialized by the default configuration of HyperlinkedRelatedField(many=True) : { \"id\": 11, \"title\": \"title 11\", \"body\": \"post 11\", \"comments\": [ \"http://example.com/api/comments/9/\", \"http://example.com/api/comments/10/\", \"http://example.com/api/comments/11/\" ] } As alluded to previously, related records can be retrieved in a single request by creating a custom ViewSet that allows the related records to be retrieved from a nested URL. For example, the blog post json hash would now have a single URL for the related comments instead of one URL per related record: { \"id\": 11, \"title\": \"title 11\", \"body\": \"post 11\", \"comments\": \"http://example.com/api/posts/11/comments/\" } Note: It is also possible to use the Coalesce Find Requests feature to retrieve related records in a single request, however, this is the preferred solution.","title":"Hyperlinked Related Fields"},{"location":"hyperlinked-related-fields/#models-serializers-and-router","text":"We can create a blog post hash with the related comments URL by using the following models, serializers and router: # models.py class Post(models.Model): title = models.CharField(max_length=100) body = models.TextField() class Comment(models.Model): body = models.TextField() post = models.ForeignKey('Post', related_name='comments') # serializers.py class PostSerializer(serializers.HyperlinkedModelSerializer): comments = serializers.HyperlinkedIdentityField(view_name='post-comments') class Meta: model = Post fields = ('id', 'title', 'body', 'comments') class CommentSerializer(serializers.HyperlinkedModelSerializer): class Meta: model = Comment fields = ('id', 'body', 'post') # urls.py router = DefaultRouter() router.register(r'posts', PostViewSet) urlpatterns = router.urls","title":"Models, Serializers and Router"},{"location":"hyperlinked-related-fields/#viewset","text":"The nested comments URL is achieved by adding a @detail_route decorator on the comments method of the PostViewSet . The related comments are manually retrieved from the database and serialized. # views.py class PostViewSet(viewsets.ModelViewSet): serializer_class = PostSerializer queryset = Post.objects.all() @detail_route() def comments(self, request, pk=None): post = self.get_object() serializer = CommentSerializer(post.comments.all(), context={'request': request}, many=True) return Response(serializer.data) For example, retrieving the comments @detail_route using this nested URL http://example.com/api/posts/11/comments/ returns all of the related comments for post 11. [ { \"id\": 9, \"body\": \"comment 9\", \"post\": \"http://example.com/api/posts/11/\" }, { \"id\": 14, \"body\": \"comment 14\", \"post\": \"http://example.com/api/posts/11/\" } ]","title":"ViewSet"},{"location":"hyperlinked-related-fields/#write-operations","text":"In this example, the comments @detail_route is read-only. If you need to perform write operations on the specific related records (e.g. create, update or delete specific comments), you would need to add a top level API with the required operations for the related model (e.g. CommentViewSet on the /api/comments/ resource).","title":"Write Operations"},{"location":"non-field-errors/","text":"Non field errors By default, Django REST Framework stores non field errors in a key named 'non_field_errors' whenever there is a validation error (HTTP status 400). Django REST Framework allows to customize the name of this key. If you changed the default value, you will need to extend the adapter and set nonFieldErrorsKey in app/adapters/application.js : // app/adapters/application.js import DRFAdapter from './drf'; export default DRFAdapter.extend({ nonFieldErrorKey: 'my_key_name_is_waaay_cooler' }); In the case of an InvalidError being raised by the adapter when the response contains non-field errors, the adapter will include in the errors array a jsonapi error object of the form: { detail: 'error 1', source: { pointer: 'data' }, title: 'Validation Error' } //or whatever key name you configured In case of several errors, the InvalidError.errors attribute will include { detail: 'error 1', source: { pointer: 'data' }, title: 'Validation Error' } //or whatever key name you configured { detail: 'error 2', source: { pointer: 'data' }, title: 'Validation Error' } //or whatever key name you configured","title":"Non field errors"},{"location":"non-field-errors/#non-field-errors","text":"By default, Django REST Framework stores non field errors in a key named 'non_field_errors' whenever there is a validation error (HTTP status 400). Django REST Framework allows to customize the name of this key. If you changed the default value, you will need to extend the adapter and set nonFieldErrorsKey in app/adapters/application.js : // app/adapters/application.js import DRFAdapter from './drf'; export default DRFAdapter.extend({ nonFieldErrorKey: 'my_key_name_is_waaay_cooler' }); In the case of an InvalidError being raised by the adapter when the response contains non-field errors, the adapter will include in the errors array a jsonapi error object of the form: { detail: 'error 1', source: { pointer: 'data' }, title: 'Validation Error' } //or whatever key name you configured In case of several errors, the InvalidError.errors attribute will include { detail: 'error 1', source: { pointer: 'data' }, title: 'Validation Error' } //or whatever key name you configured { detail: 'error 2', source: { pointer: 'data' }, title: 'Validation Error' } //or whatever key name you configured","title":"Non field errors"},{"location":"pagination/","text":"Pagination Pagination is supported using the metadata support that is built into Ember Data. Metadata from Django REST Framework paginated list views is updated on every request to the server. The pagination support in EDA works with the default pagination setup in DRF 3.0 and the PageNumberPagination class in DRF 3.1. It's possible to use the other DRF 3.1 pagination classes by overriding extractMeta (see customizing the Metadata below). Accessing the Metadata To get a page of records, simply run a query request with the page query param. let result = this.store.query('post', {page: 1}); All of the DRF metadata (including the pagination metadata) can be access through the meta property of the result once the promise is fulfilled. let meta = result.get('meta'); Note: The meta property will only be set on results of query requests. Pagination Metadata The pagination metadata consists of three properties that give the application enough information to paginate through a Django REST Framework paginated list view. next - The next page number or null when there is no next page (i.e. the last page). previous - The previous page number or null when there is no previous page (i.e. the first page). count - The total number of records available. This can be used along with the page size to calculate the total number of pages (see customizing the Metadata below). The next and previous page number can be used directly as the value of the page query param. null is not a valid value for the page query param so applications need to check if next and previous are null before using them. if (meta.next) { result = store.query('post', {page: meta.next}) } Customizing the Metadata You can customize the metadata by overriding the extractMeta and adding and / or removing metadata as indicated in this template. // app/serializer/<model>.js import Ember from 'ember'; import DRFSerializer from './drf'; export default DRFSerializer.extend({ extractMeta: function(store, type, payload) { let meta = this._super(store, type, payload); if (!Ember.isNone(meta)) { // Add or remove metadata here. } return meta; } }); This version of extractMeta adds the total page count to the post metadata. // app/serializer/post.js import Ember from 'ember'; import DRFSerializer from './drf'; export default DRFSerializer.extend({ extractMeta: function(store, type, payload) { let meta = this._super(store, type, payload); if (!Ember.isNone(meta)) { // Add totalPages to metadata. let totalPages = 1; if (!Ember.isNone(meta.next)) { // Any page that is not the last page. totalPages = Math.ceil(meta.count / payload[type.modelName].length); } else if (Ember.isNone(meta.next) && !Ember.isNone(meta.previous)) { // The last page when there is more than one page. totalPages = meta.previous + 1; } meta['totalPages'] = totalPages; } return meta; } }); Cursor Pagination To use CursorPagination , override extractPageNumber in the serializer to extract the cursor . // app/serializer/drf.js import DRFSerializer from 'ember-django-adapter/serializers/drf'; export default DRFSerializer.extend({ extractPageNumber: function(url) { var match = /.*?[\\?&]cursor=([A-Za-z0-9]+).*?/.exec(url); if (match) { return match[1]; } return null; } }); If you don't use the PageNumberPagination for pagination with DRF 3.1 you can also add the metadata for the pagination scheme you use here. We may add support for the other pagination classes in the future. If this is something you are interested in contributing, please file an issue on github.","title":"Pagination"},{"location":"pagination/#pagination","text":"Pagination is supported using the metadata support that is built into Ember Data. Metadata from Django REST Framework paginated list views is updated on every request to the server. The pagination support in EDA works with the default pagination setup in DRF 3.0 and the PageNumberPagination class in DRF 3.1. It's possible to use the other DRF 3.1 pagination classes by overriding extractMeta (see customizing the Metadata below).","title":"Pagination"},{"location":"pagination/#accessing-the-metadata","text":"To get a page of records, simply run a query request with the page query param. let result = this.store.query('post', {page: 1}); All of the DRF metadata (including the pagination metadata) can be access through the meta property of the result once the promise is fulfilled. let meta = result.get('meta'); Note: The meta property will only be set on results of query requests.","title":"Accessing the Metadata"},{"location":"pagination/#pagination-metadata","text":"The pagination metadata consists of three properties that give the application enough information to paginate through a Django REST Framework paginated list view. next - The next page number or null when there is no next page (i.e. the last page). previous - The previous page number or null when there is no previous page (i.e. the first page). count - The total number of records available. This can be used along with the page size to calculate the total number of pages (see customizing the Metadata below). The next and previous page number can be used directly as the value of the page query param. null is not a valid value for the page query param so applications need to check if next and previous are null before using them. if (meta.next) { result = store.query('post', {page: meta.next}) }","title":"Pagination Metadata"},{"location":"pagination/#customizing-the-metadata","text":"You can customize the metadata by overriding the extractMeta and adding and / or removing metadata as indicated in this template. // app/serializer/<model>.js import Ember from 'ember'; import DRFSerializer from './drf'; export default DRFSerializer.extend({ extractMeta: function(store, type, payload) { let meta = this._super(store, type, payload); if (!Ember.isNone(meta)) { // Add or remove metadata here. } return meta; } }); This version of extractMeta adds the total page count to the post metadata. // app/serializer/post.js import Ember from 'ember'; import DRFSerializer from './drf'; export default DRFSerializer.extend({ extractMeta: function(store, type, payload) { let meta = this._super(store, type, payload); if (!Ember.isNone(meta)) { // Add totalPages to metadata. let totalPages = 1; if (!Ember.isNone(meta.next)) { // Any page that is not the last page. totalPages = Math.ceil(meta.count / payload[type.modelName].length); } else if (Ember.isNone(meta.next) && !Ember.isNone(meta.previous)) { // The last page when there is more than one page. totalPages = meta.previous + 1; } meta['totalPages'] = totalPages; } return meta; } });","title":"Customizing the Metadata"},{"location":"pagination/#cursor-pagination","text":"To use CursorPagination , override extractPageNumber in the serializer to extract the cursor . // app/serializer/drf.js import DRFSerializer from 'ember-django-adapter/serializers/drf'; export default DRFSerializer.extend({ extractPageNumber: function(url) { var match = /.*?[\\?&]cursor=([A-Za-z0-9]+).*?/.exec(url); if (match) { return match[1]; } return null; } }); If you don't use the PageNumberPagination for pagination with DRF 3.1 you can also add the metadata for the pagination scheme you use here. We may add support for the other pagination classes in the future. If this is something you are interested in contributing, please file an issue on github.","title":"Cursor Pagination"},{"location":"trailing-slashes/","text":"Trailing Slashes By default, Django REST Framework adds trailing slashes to its generated URLs. EDA is set up to handle this, however, if you have decided to opt out of trailing slashes, you will need to extend the adapter with this configuration. e.g., if you have set up a router in DRF that is instantiated like this: from rest_framework import routers router = routers.DefaultRouter(trailing_slash=False) then you will need to extend the adapter and switch off addTrailingSlashes in app/adapters/application.js : // app/adapters/application.js import DRFAdapter from './drf'; export default DRFAdapter.extend({ addTrailingSlashes: false });","title":"Trailing Slashes"},{"location":"trailing-slashes/#trailing-slashes","text":"By default, Django REST Framework adds trailing slashes to its generated URLs. EDA is set up to handle this, however, if you have decided to opt out of trailing slashes, you will need to extend the adapter with this configuration. e.g., if you have set up a router in DRF that is instantiated like this: from rest_framework import routers router = routers.DefaultRouter(trailing_slash=False) then you will need to extend the adapter and switch off addTrailingSlashes in app/adapters/application.js : // app/adapters/application.js import DRFAdapter from './drf'; export default DRFAdapter.extend({ addTrailingSlashes: false });","title":"Trailing Slashes"}]}